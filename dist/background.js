import{g as l,i as s,a as c,t as i,v as u,s as h,b as f,c as x,u as b,e as y,d as m}from"./vectordb.js";async function d(){if(!(c()>0))return new Promise(e=>{chrome.storage.local.get("vocab",t=>{t.vocab?(s(t.vocab),console.log("[xUpload] Vocab loaded:",c(),"terms")):console.warn("[xUpload] No vocab found."),e()})})}d();chrome.runtime.onMessage.addListener((e,t,a)=>{if(e.type==="MATCH_REQUEST")return E(e).then(a),!0;if(e.type==="GET_FILE")return g(e.id).then(a),!0;if(e.type==="GET_INDEX_COUNT")return l().then(r=>a({count:r})),!0;if(e.type==="BUILD_INDEX")return U(e.files).then(a),!0;if(e.type==="VOCAB_UPDATED")return chrome.storage.local.get("vocab",r=>{r.vocab&&(s(r.vocab),console.log("[xUpload] Vocab reloaded:",c(),"terms")),a({ok:!0})}),!0});async function E(e){await d(),console.log("[xUpload] MATCH context:",e.context.slice(0,100));const t=i(e.context),a=u(t);if(a.length===0)return console.warn("[xUpload] Empty vector â€” vocab size:",c()),{type:"MATCH_RESPONSE",results:[]};const r=await h(a,5,e.accept);return console.log("[xUpload] Results:",r.map(o=>`${o.record.name} (${Math.round(o.score*100)}%)`)),{type:"MATCH_RESPONSE",results:r.map(o=>({id:o.record.id,name:o.record.name,path:o.record.path,type:o.record.type,score:o.score}))}}async function U(e){console.log("[xUpload] BUILD_INDEX:",e.length,"files");const t=e.map(o=>i(o.text));f(t),await x();for(let o=0;o<e.length;o++){const n=e[o],p=u(t[o]);await b({id:n.path,name:n.name,path:n.path,type:n.type,size:n.size,lastModified:n.lastModified,vector:p,textPreview:n.text.slice(0,100)})}const a=y();await new Promise(o=>{chrome.storage.local.set({vocab:a},o)});const r=await l();return console.log("[xUpload] Index built:",r,"files"),{ok:!0,count:r}}async function g(e){console.log("[xUpload] GET_FILE:",e);const t=await m(e);return t?(console.log("[xUpload] Sending:",t.name),t):{error:"Cannot read file. Please re-scan the folder from the xUpload popup."}}
